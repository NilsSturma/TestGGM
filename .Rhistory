cl <- makeCluster(cores, outfile = "")
registerDoParallel(cl)
sizes <- foreach(nr = 1:nr_exp, .combine=rbind, .packages=c("MASS", "CombMSC")) %dopar% {
# Print some information regarding the progress (doesn't work with R-studio)
if(!as.logical(nr%%10)){
print(nr)
}
#  Check the setup
if (!(setup%in%c(1,2))){
return("ERROR! Setup not possible!")
# Could add a check that m>=3 for setup 2
}
# Generate n independent data sets
if (setup==1){
beta = rep(1,m)
Sigma = beta %*% t(beta) + diag(rep(1,m))
}
if (setup==2){
beta = c(10,10, rnorm((m-2),0,0.2))
Sigma = beta %*% t(beta) + diag(rep(1/3,m))
}
#set.seed(seed)
X =  mvrnorm(n, mu=rep(0,m), Sigma=Sigma)
# Call the test
res = star_tree_test(X, E=E, alphas=alphas)
as.numeric(res)
}
sizes = colMeans(sizes)
stopCluster(cl)
############################################
# Plot results (and save it in a pdf file) #
############################################
subtitle = paste("Setup ", setup, ", (m,n) = (", m, ",", n, ")", sep="")
title = paste("Emprical test sizes vs. nominal test levels based on ", nr_exp, " experiments", sep="")
if (save){
name = paste("star-tree_setup", setup, "_", m, "_", n, ".pdf", sep="")
pdf(name) # create pdf file
}
plot(alphas, sizes,
xlab="Nominal level", ylab="Emprical test size", main=title, sub=subtitle,
type="p", pch=1)
abline(coef = c(0,1))
if (save){
dev.off() # close pdf file
}
library(igraph)
g = graph_from_literal(1--6--7--8--4, 2--6--7--8--3, 7--5)
E(g) # this gives all edges
length(E(g))
E(g)$weight <- c(1,1,1,1,1,1,1)
E(g)$weight
V(g)
length(V(g))
V(g)$type <- c(1,2,2,2,1,1,1,1) #1=observed
V(g)$type
colors <- c("tomato", "gray50")
V(g)$color <- colors[V(g)$type]
V(g)$color
plot(g)
g
library(MASS) #mvrnorm
library(CombMSC) #subsets
library(foreach)
library(doParallel)
# Testing the star tree (method: dividing X into two datasets of size n/2)
star_tree_test <- function(X, E=1000, alphas=seq(0.01, 0.99, 0.01)){
n = dim(X)[1]
m = dim(X)[2]
#############################################
# divide X into X1 and X2, both of size n/2 #
#############################################
X1 = X[1:(n/2),]
X2 = X[((n/2)+1):n, ]
# Could add a test that n/2 is a natural number (or use floor(n/2))
######################################################################################
# Compute Y_i, i=1,...,(n-1), Y_mean and the batched mean estimator for diag(cov(Y)) #
######################################################################################
sub_sets = subsets(m,4,1:m)
# Compute Y (unbiased estimated of the tetrads)
Y = matrix(0, nrow = n/2, ncol = 2 * choose(m,4))
for (j in 1:nrow(sub_sets)){
p = sub_sets[j,1]
q = sub_sets[j,2]
r = sub_sets[j,3]
s = sub_sets[j,4]
Y[,j*2-1] = X1[,p] * X1[,s] * X2[,q] * X2[,r] - X1[,p] * X1[,r] * X2[,q] * X2[,s]
Y[,j*2] = X1[,p] * X1[,q] * X2[,s] * X2[,r] - X1[,p] * X1[,r] * X2[,q] * X2[,s]
}
##########################
# Compute test statistic #
##########################
test_stat = max(abs( (1/sqrt((n/2))) * colSums(Y) ))
##### We need absolute values here to have a two sided test, correct? #####
#################
# Bootstrapping #
#################
results = rep(0, E)
for (i in 1:E){
epsilons = rnorm((n/2), mean=0, sd=1)  # Set seed here?
results[i] = max(abs( (1/sqrt((n/2))) * colSums(Y*epsilons) ))
##### We need absolute values here to have a two sided test, correct? #####
}
# Compute critical values
critical_values = quantile(results, probs=1-alphas)
#print(critical_values)
# Reject if test_stat > critical_value
is_rejected = test_stat > critical_values
return(is_rejected)
}
####################################################################################################################
####################################################################################################################
#################
# Set variables #
#################
m = 20
n = 500
setup = 1
E = 1000
alphas = seq(0.01, 0.99, 0.01)
nr_exp = 500
save=TRUE
###############################################
# Compute empirical test sizes for all alphas #
###############################################
cores = detectCores()
cl <- makeCluster(cores, outfile = "")
registerDoParallel(cl)
sizes <- foreach(nr = 1:nr_exp, .combine=rbind, .packages=c("MASS", "CombMSC")) %dopar% {
# Print some information regarding the progress (doesn't work with R-studio)
if(!as.logical(nr%%10)){
print(nr)
}
#  Check the setup
if (!(setup%in%c(1,2))){
return("ERROR! Setup not possible!")
# Could add a check that m>=3 for setup 2
}
# Generate n independent data sets
if (setup==1){
beta = rep(1,m)
Sigma = beta %*% t(beta) + diag(rep(1,m))
}
if (setup==2){
beta = c(10,10, rnorm((m-2),0,0.2))
Sigma = beta %*% t(beta) + diag(rep(1/3,m))
}
#set.seed(seed)
X =  mvrnorm(n, mu=rep(0,m), Sigma=Sigma)
# Call the test
res = star_tree_test(X, E=E, alphas=alphas)
as.numeric(res)
}
sizes = colMeans(sizes)
stopCluster(cl)
############################################
# Plot results (and save it in a pdf file) #
############################################
subtitle = paste("Setup ", setup, ", (m,n) = (", m, ",", n, ")", sep="")
title = paste("Emprical test sizes vs. nominal test levels based on ", nr_exp, " experiments", sep="")
if (save){
name = paste("star-tree_setup", setup, "_", m, "_", n, ".pdf", sep="")
pdf(name) # create pdf file
}
plot(alphas, sizes,
xlab="Nominal level", ylab="Emprical test size", main=title, sub=subtitle,
type="p", pch=1)
abline(coef = c(0,1))
if (save){
dev.off() # close pdf file
}
library(MASS) #mvrnorm
library(CombMSC) #subsets
library(foreach)
library(doParallel)
# Testing the star tree (method: dividing X into two datasets of size n/2)
star_tree_test <- function(X, E=1000, alphas=seq(0.01, 0.99, 0.01)){
n = dim(X)[1]
m = dim(X)[2]
#############################################
# divide X into X1 and X2, both of size n/2 #
#############################################
X1 = X[1:(n/2),]
X2 = X[((n/2)+1):n, ]
# Could add a test that n/2 is a natural number (or use floor(n/2))
######################################
# Compute Y_i, i=1,...,(n-1), Y_mean #
######################################
sub_sets = subsets(m,4,1:m)
# Compute Y (unbiased estimated of the tetrads)
Y = matrix(0, nrow = n/2, ncol = 2 * choose(m,4))
for (j in 1:nrow(sub_sets)){
p = sub_sets[j,1]
q = sub_sets[j,2]
r = sub_sets[j,3]
s = sub_sets[j,4]
Y[,j*2-1] = X1[,p] * X1[,s] * X2[,q] * X2[,r] - X1[,p] * X1[,r] * X2[,q] * X2[,s]
Y[,j*2] = X1[,p] * X1[,q] * X2[,s] * X2[,r] - X1[,p] * X1[,r] * X2[,q] * X2[,s]
}
##########################
# Compute test statistic #
##########################
test_stat = max(abs( (1/sqrt((n/2))) * colSums(Y) ))
##### We need absolute values here to have a two sided test, correct? #####
#################
# Bootstrapping #
#################
results = rep(0, E)
for (i in 1:E){
epsilons = rnorm((n/2), mean=0, sd=1)  # Set seed here?
results[i] = max(abs( (1/sqrt((n/2))) * colSums(Y*epsilons) ))
##### We need absolute values here to have a two sided test, correct? #####
}
# Compute critical values
critical_values = quantile(results, probs=1-alphas)
#print(critical_values)
# Reject if test_stat > critical_value
is_rejected = test_stat > critical_values
return(is_rejected)
}
####################################################################################################################
####################################################################################################################
#################
# Set variables #
#################
m = 20
n = 500
setup = 1
E = 1000
alphas = seq(0.01, 0.99, 0.01)
nr_exp = 500
save=TRUE
###############################################
# Compute empirical test sizes for all alphas #
###############################################
cores = detectCores()
cl <- makeCluster(cores, outfile = "")
registerDoParallel(cl)
sizes <- foreach(nr = 1:nr_exp, .combine=rbind, .packages=c("MASS", "CombMSC")) %dopar% {
# Print some information regarding the progress (doesn't work with R-studio)
if(!as.logical(nr%%10)){
print(nr)
}
# Generate n independent data sets
if (setup==1){
beta = rep(1,m)
Sigma = beta %*% t(beta) + diag(rep(1,m))
}
if (setup==2){
beta = c(10,10, rnorm((m-2),0,0.2))
Sigma = beta %*% t(beta) + diag(rep(1/3,m))
}
set.seed(nr)
X =  mvrnorm(n, mu=rep(0,m), Sigma=Sigma)
# Call the test
res = star_tree_test(X, E=E, alphas=alphas)
as.numeric(res)
}
sizes = colMeans(sizes)
stopCluster(cl)
############################################
# Plot results (and save it in a pdf file) #
############################################
subtitle = paste("Setup ", setup, ", (m,n) = (", m, ",", n, ")", sep="")
title = paste("Emprical test sizes vs. nominal test levels based on ", nr_exp, " experiments", sep="")
if (save){
name = paste("star-tree_setup", setup, "_", m, "_", n, ".pdf", sep="")
pdf(name) # create pdf file
}
plot(alphas, sizes,
xlab="Nominal level", ylab="Emprical test size", main=title, sub=subtitle,
type="p", pch=1)
abline(coef = c(0,1))
if (save){
dev.off() # close pdf file
}
beta = rep(1,10)
Sigma = beta %*% t(beta) + diag(rep(1,10))
X = mvrnorm(20, mu=rep(0,10), Sigma=Sigma)
X
Sigma
BETA = matrix(rep(beta,10), nrow=20, byrow=TRUE)
BETA
BETA = matrix(rep(beta,20), nrow=20, byrow=TRUE)
BETA
BETA = matrix(rep(seq(1,10),20), nrow=20, byrow=TRUE)
BETA
H
H = rnorm(20, 0,1)
H
BETA*H
dim(BETA)
length(H)
BETA*H
dim(BETA*H)
H
BETA
BETA = matrix(rep(beta,20), nrow=20, byrow=TRUE)
H
dim(BETA*H)
BETA*H
matrix(rnorm(20*10,0,1), nrow=20)
BETA*H + matrix(rnorm(20*10,0,1), nrow=20)
beta = rep(1,10)
Sigma = beta %*% t(beta) + diag(rep(1,10))
X = mvrnorm(20, mu=rep(0,10), Sigma=Sigma)
X
library(MASS) #mvrnorm
library(CombMSC) #subsets
library(foreach)
library(doParallel)
# Testing the star tree (method: dividing X into two datasets of size n/2)
star_tree_test <- function(X, E=1000, alphas=seq(0.01, 0.99, 0.01)){
n = dim(X)[1]
m = dim(X)[2]
#############################################
# divide X into X1 and X2, both of size n/2 #
#############################################
X1 = X[1:(n/2),]
X2 = X[((n/2)+1):n, ]
# Could add a test that n/2 is a natural number (or use floor(n/2))
######################################
# Compute Y_i, i=1,...,(n-1), Y_mean #
######################################
sub_sets = subsets(m,4,1:m)
# Compute Y (unbiased estimated of the tetrads)
Y = matrix(0, nrow = n/2, ncol = 2 * choose(m,4))
for (j in 1:nrow(sub_sets)){
p = sub_sets[j,1]
q = sub_sets[j,2]
r = sub_sets[j,3]
s = sub_sets[j,4]
Y[,j*2-1] = X1[,p] * X1[,s] * X2[,q] * X2[,r] - X1[,p] * X1[,r] * X2[,q] * X2[,s]
Y[,j*2] = X1[,p] * X1[,q] * X2[,s] * X2[,r] - X1[,p] * X1[,r] * X2[,q] * X2[,s]
}
##########################
# Compute test statistic #
##########################
test_stat = max(abs( (1/sqrt((n/2))) * colSums(Y) ))
##### We need absolute values here to have a two sided test #####
#################
# Bootstrapping #
#################
results = rep(0, E)
for (i in 1:E){
epsilons = rnorm((n/2), mean=0, sd=1)
results[i] = max(abs( (1/sqrt((n/2))) * colSums(Y*epsilons) ))
##### We need absolute values here to have a two sided test #####
}
# Compute critical values
critical_values = quantile(results, probs=1-alphas)
# Reject if test_stat > critical_value
is_rejected = test_stat > critical_values
return(is_rejected)
}
####################################################################################################################
####################################################################################################################
#################
# Set variables #
#################
m = 20
n = 2000
setup = 1
E = 1000
alphas = seq(0.01, 0.99, 0.01)
nr_exp = 500
save=TRUE
###############################################
# Compute empirical test sizes for all alphas #
###############################################
cores = detectCores()
cl <- makeCluster(cores, outfile = "")
registerDoParallel(cl)
sizes <- foreach(nr = 1:nr_exp, .combine=rbind, .packages=c("MASS", "CombMSC")) %dopar% {
# Print some information regarding the progress (doesn't work with R-studio)
if(!as.logical(nr%%10)){
print(nr)
}
# Generate n independent data sets
if (setup==1){
beta = rep(1,m)
Sigma = beta %*% t(beta) + diag(rep(1,m))
}
if (setup==2){
beta = c(10,10, rnorm((m-2),0,0.2))
Sigma = beta %*% t(beta) + diag(rep(1/3,m))
}
#set.seed(nr)
X = mvrnorm(n, mu=rep(0,m), Sigma=Sigma)
# Call the test
res = star_tree_test(X, E=E, alphas=alphas)
as.numeric(res)
}
sizes = colMeans(sizes)
stopCluster(cl)
############################################
# Plot results (and save it in a pdf file) #
############################################
subtitle = paste("Setup ", setup, ", (m,n) = (", m, ",", n, ")", sep="")
title = paste("Emprical test sizes vs. nominal test levels based on ", nr_exp, " experiments", sep="")
if (save){
name = paste("star-tree_setup", setup, "_", m, "_", n, ".pdf", sep="")
pdf(name) # create pdf file
}
plot(alphas, sizes,
xlab="Nominal level", ylab="Emprical test size", main=title, sub=subtitle,
type="p", pch=1)
abline(coef = c(0,1))
if (save){
dev.off() # close pdf file
}
sys.time()
Sys.time()
Sys.Date()
format(Sys.time(), "%a %b %d %X %Y")
format(Sys.time(), "%Y-%m-%dT%H:%M:%S%z")
format(Sys.time(), "%Y-%m-%d-%H-%M")
if (save){
name = paste(format(Sys.time(), "%Y-%m-%d-%H-%M"), "_", "star-tree_setup", setup, "_", m, "_", n, ".pdf", sep="")
pdf(name) # create pdf file
}
plot(alphas, sizes,
xlab="Nominal level", ylab="Emprical test size", main=title, sub=subtitle,
type="p", pch=1)
abline(coef = c(0,1))
if (save){
dev.off() # close pdf file
}
sizes
saveRDS(sizes, file = name)
# Plot
if (save){
name_pdf = paste(format(Sys.time(), "%Y-%m-%d-%H-%M"), "_", "star-tree_setup", setup, "_", m, "_", n, ".pdf", sep="")
name_rds = paste(format(Sys.time(), "%Y-%m-%d-%H-%M"), "_", "star-tree_setup", setup, "_", m, "_", n, ".rds", sep="")
saveRDS(sizes, file = name_rds)
pdf(name_pdf) # create pdf file
}
plot(alphas, sizes,
xlab="Nominal level", ylab="Emprical test size", main=title, sub=subtitle,
type="p", pch=1)
abline(coef = c(0,1))
if (save){
dev.off() # close pdf file
}
readRDS("2020-09-06-09-51_star-tree_setup1_20_2000.rds")
sizes
sizes2 = readRDS("2020-09-06-09-51_star-tree_setup1_20_2000.rds")
sizes=sizes2
source(star-trees.R)
source("star-trees.R")
library(foreach)
library(doParallel)
library(foreach)
library(doParallel)
source("star-trees.R")
#################
# Set variables #
#################
m = 8
n = 500
setup = 1
E = 1000
alphas = seq(0.01, 0.99, 0.01)
nr_exp = 50
save=TRUE
###############################################
# Compute empirical test sizes for all alphas #
###############################################
cores = detectCores()
cl <- makeCluster(cores, outfile = "")
registerDoParallel(cl)
sizes <- foreach(nr = 1:nr_exp, .combine=rbind, .packages=c("MASS", "CombMSC")) %dopar% {
# Print some information regarding the progress (doesn't work with R-studio)
if(!as.logical(nr%%10)){
print(nr)
}
# Generate n independent data sets
if (setup==1){
beta = rep(1,m)
Sigma = beta %*% t(beta) + diag(rep(1,m))
}
if (setup==2){
beta = c(10,10, rnorm((m-2),0,0.2))
Sigma = beta %*% t(beta) + diag(rep(1/3,m))
}
#set.seed(nr)
X = mvrnorm(n, mu=rep(0,m), Sigma=Sigma)
# Call the test
res = test_half_and_half(X, E=E, alphas=alphas)
as.numeric(res)
}
sizes = colMeans(sizes)
stopCluster(cl)
#########################
# Plot and save results #
#########################
subtitle = paste("Setup ", setup, ", (m,n) = (", m, ",", n, ")", sep="")
title = paste("Emprical test sizes vs. nominal test levels based on ", nr_exp, " experiments", sep="")
# Plot
if (save){
# use "./img/name.png" to save in subdirectory
name_pdf = paste(format(Sys.time(), "%Y-%m-%d-%H-%M"), "_", "star-tree_setup", setup, "_", m, "_", n, ".pdf", sep="")
name_rds = paste(format(Sys.time(), "%Y-%m-%d-%H-%M"), "_", "star-tree_setup", setup, "_", m, "_", n, ".rds", sep="")
saveRDS(sizes, file = name_rds) # read with readRDS()
pdf(name_pdf) # create pdf file
}
plot(alphas, sizes,
xlab="Nominal level", ylab="Emprical test size", main=title, sub=subtitle,
type="p", pch=1)
abline(coef = c(0,1))
if (save){
dev.off() # close pdf file
}
